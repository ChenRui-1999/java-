### 文章目录

- [1.PC 寄存器介绍](https://blog.csdn.net/sj15814963053/article/details/109864077#1PC__12)
- [2.PC 寄存器的作用](https://blog.csdn.net/sj15814963053/article/details/109864077#2PC__27)
- [3.代码示例](https://blog.csdn.net/sj15814963053/article/details/109864077#3_35)
- [4.两个常见面试题](https://blog.csdn.net/sj15814963053/article/details/109864077#4_63)
- [5.CPU时间片](https://blog.csdn.net/sj15814963053/article/details/109864077#5CPU_87)



------

[官网文档](https://docs.oracle.com/javase/specs/jvms/se8/html/index.html)

![image-20201120194057924](https://img-blog.csdnimg.cn/img_convert/903f65cd49b02d9e8817b6f9be08221c.png)

# 1.PC 寄存器介绍

![img](https://img-blog.csdnimg.cn/img_convert/10d8620a08bcd128b95f7cdc7a56694f.png)

- JVM中的程序计数寄存器（Program Counter Register），Register的命名源于CPU的寄存器，寄存器存储指令相关的现场信息。CPU只有把数据装载到寄存器才能够运行。

- 这里，并非是广义上所指的物理寄存器，或许将其翻译为PC计数器（或指令计数器）会更加贴切（也称为程序钩子），并且也不容易引起一些不必要的误会。JVM中的PC寄存器是对物理PC寄存器的一种抽象模拟。

- 它是一块很小的内存空间，几乎可以忽略不记。也是运行速度最快的存储区域。
- `在JVM规范中，每个线程都有它自己的程序计数器`，是线程私有的，`生命周期与线程的生命周期保持一致`。

- 任何时间一个线程都只有一个方法在执行，也就是所谓的当前方法。程序计数器会存储当前线程正在执行的Java方法的JVM指令地址；或者，`如果是在执行native方法，则是未指定值（undefined）`。

- 它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成
- 字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令。

- 它是唯一一个在Java虚拟机规范中没有规定任何`OutofMemoryError`情况的区域。

# 2.PC 寄存器的作用

```
PC寄存器用来存储指向下一条指令的地址，也就是即将要执行的指令代码。由执行引擎读取下一条指令，并执行该指令。
```

![image-20200705155728557](https://img-blog.csdnimg.cn/img_convert/539e339e3e2800f0f2de9293fe426390.png)

# 3.代码示例

# 

```java
public class PCRegisterTest {
public static void main(String[] args) {
    int i = 10;
    int j = 20;
    int k = i + j;

    String s = "abc";
    System.out.println(i);
    System.out.println(k);

}
}
```

使用反编译：javap -v PCRegisterTest.class

左边的数字代表指令地址 (偏移地址)，即 PC 寄存器中可能存储的值，然后执行引擎读取 PC 寄存器中的值，并执行该指令

![image-20201120201517607](https://img-blog.csdnimg.cn/img_convert/9a908396af919b71efa699db077fa35e.png)

![image-20201120202417439](https://gitee.com/xu3619/Javase/raw/master/img/20201120202417.png)

# 4.两个常见面试题

使用 PC寄存器 存储字节码指令地址有什么用呢？

或者问

为什么使用 PC寄存器 来记录当前线程的执行地址呢？



- 因为线程是一个个的顺序执行流，CPU需要不停的切换各个线程，这时候切换回来以后，就得知道接着从哪开始继续执行
- JVM的字节码解释器就需要通过改变PC寄存器的值来明确下一条应该执行什么样的字节码指令

![第04章_PC寄存器](https://gitee.com/xu3619/Javase/raw/master/img/20201120202625.jpg)

PC寄存器为什么被设定为私有的？

-  一个特定的时间段内只会执行其中某一个线程的方法，CPU会不停地做任务切换，这样必然导致经常中断或恢复，如何保证分毫无差呢？

- `为了能够准确地记录各个线程正在执行的当前字节码指令地址，最好的办法自然是为每一个线程都分配一个PC寄存器，这样一来各个线程之间便可以进行独立计算，从而不会出现相互干扰的情况`。

- 由于CPU时间片轮限制，众多线程在并发执行过程中，任何一个确定的时刻，一个处理器或者多核处理器中的一个内核，只会执行某个线程中的一条指令。
- 这样必然导致经常中断或恢复，如何保证分毫无差呢？每个线程在创建后，都会产生自己的程序计数器和栈帧，程序计数器在各个线程之间互不影响。

# 5.CPU时间片

![image-20200705161849557](https://img-blog.csdnimg.cn/img_convert/9b8a2691dee33d9e2a02c3c80d26c6d0.png)

- CPU时间片即CPU分配给各个程序的时间，每个线程被分配一个时间段，称作它的时间片。
- 在宏观上：我们可以同时打开多个应用程序，每个程序并行不悖，同时运行。
- 但在微观上：由于只有一个CPU，一次只能处理程序要求的一部分，如何处理公平，一种方法就是引入时间片，每个程序轮流执行。

简单一句话：宏观并行，微观并发

## 并行和并发的区别？

**并发：一个处理器可以同时处理多个任务。这是逻辑上的同时发生。
并行：多个处理器同时处理多个不同的任务。这是物理上的同时发生。
有一个清晰地比喻：
并发：一个人同时吃三个苹果。并行：三个人同时吃三个苹果。**

## 图文并茂：

## 并发（concurrency）：

指同一时刻只能够执行一条指令，但是多条指令被快速的进行切换，给人造成了它们同时执行的感觉。但在微观来说，并不同同时进行的，只是划分时间段，分别进行执行。

![在这里插入图片描述](https://img-blog.csdnimg.cn/20190523181852896.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDI2ODA5,size_16,color_FFFFFF,t_70)

## 并行（parallel）：

在同一时刻，有多条指令在多个处理器上同时执行。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190523181839145.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDI2ODA5,size_16,color_FFFFFF,t_70)